// Photoshop Plug-in for converting a fishyey image // to square for 3dcg texture, made by // Hirofumi Inomata, (C) 2003// I disclose AS-IS, only a main part, "do.c", for the plug-in,// with BSD License. And it had included some flugments // with cut & try, also. Enjoy It!////#define	__SINGLEPOINT__#include <math.h>#include "FishEye.h"#include <stdio.h>#define	PIE	(double)(3.1415)void DoAbout (GPtr globals){	Handle StrH;		StrH = (Handle)GetString( 1000 );	HLock( (Handle)StrH );	(void)CheckDlog( ChkDlog_ID, (StringPtr)*StrH );	HUnlock( (Handle)StrH );}void DoParameters (GPtr globals){	Handle StrH;	SysBeep( 2 );	StrH = (Handle)GetString( 1001 );	HLock( (Handle)StrH );	(void)CheckDlog( ChkDlog_ID, (StringPtr)*StrH );	HUnlock( (Handle)StrH );		globals->filter_rect = gStuff->filterRect;		globals->cur_in_rect.top =	 	globals->filter_rect.top;	globals->cur_in_rect.bottom = 	globals->filter_rect.top;	globals->cur_in_rect.left =		globals->filter_rect.left;	globals->cur_in_rect.right =	globals->filter_rect.left;		globals->cur_out_rect.top = 	globals->filter_rect.top;	globals->cur_out_rect.bottom = 	globals->filter_rect.top;	globals->cur_out_rect.left = 	globals->filter_rect.left;	globals->cur_out_rect.right = 	globals->filter_rect.left;	globals->planes = gStuff->planes;}#ifdef	__SINGLEPOINT__void GetTopRect( Rect *FilterRect, Rect *TopRect ){	TopRect->top =  FilterRect->top;	TopRect->bottom = TopRect->top + 1;		TopRect->left = FilterRect->left;	TopRect->right = TopRect->left + 1;}int GetNextRect( Rect *FilterRect, Rect *SrcRect, Rect *DstRect )// IN: Rect *SrcRect, OUT: Rect *DstRect{	DstRect->left =  SrcRect->left + 1;	DstRect->right = DstRect->left + 1;	if (DstRect->left >= FilterRect->right) {		DstRect->left = FilterRect->left;		DstRect->right = DstRect->left + 1;				DstRect->top =  SrcRect->top +1;		DstRect->bottom = DstRect->top + 1;				if (DstRect->top >= FilterRect->bottom) {			DstRect->top = DstRect->bottom = 			DstRect->left = DstRect->right = 0;			return	0;		}	}	return 1;}#else	// __SINGLEPOINT__// MULTIPOINTvoid GetTopRect( Rect *FilterRect, Rect *TopRect ){	TopRect->top =  FilterRect->top;	TopRect->bottom = TopRect->top + 1;		TopRect->left = FilterRect->left;	TopRect->right = TopRect->left + + POINTS;}int GetNextRect( Rect *FilterRect, Rect *SrcRect, Rect *DstRect )// IN: Rect *SrcRect, OUT: Rect *DstRect{	DstRect->left =  SrcRect->left + POINTS;	DstRect->right = DstRect->left + POINTS;		if (DstRect->left >= FilterRect->right) {		DstRect->left = FilterRect->left;		DstRect->right = DstRect->left + POINTS;				DstRect->top =  SrcRect->top +1;		DstRect->bottom = DstRect->top + 1;						if (DstRect->top >= FilterRect->bottom) {			DstRect->top = DstRect->bottom = 			DstRect->left = DstRect->right = 0;			return	0;		}	}		if (DstRect->right > FilterRect->right) {		DstRect->right = FilterRect->right;	}	return 1;}#endif	// __SINGLEPOINT__#ifdef	__SINGLEPOINT__void GetOrignalRect( Rect *FilterRect, Rect *ImgRect, Rect *OrgRect )// IN: Rect *ImgRect, OUT: Rect *OrgRect{	double	du, dv;	long	dx, dy;	double	R;	double	cb, sb;	double	b;		long	width, height;		long	uo, vo;	long	xo, yo;			uo = xo = (FilterRect->right + FilterRect->left)/2;	vo = yo = (FilterRect->bottom + FilterRect->top)/2;		width = (FilterRect->right - FilterRect->left)/2;	height = (FilterRect->bottom - FilterRect->top)/2;		if (width < height) {		R = (double)width;	} else {		R = (double)height;	}	du = ((double)(ImgRect->left - uo) * PIE)/(R * (double)2.0);	dv = ((double)(ImgRect->top - vo) * PIE)/(R * (double)2.0);		cb = cos( dv ) * cos( du );	sb = sqrt(1.0 - (cb * cb) );		b = R * acos( cb ) * (double)2.0 / PIE;		if ( (sb >= (double)0.0) && (sb <= (double)(1.0 / 100.0)) ) {		dx = (long)(R * cos( dv ) * sin( du ));		dy = (long)(R * sin( dv ));	} else {		dx = (long)(b * cos( dv ) * sin( du ) / sb );		dy = (long)(b * sin( dv ) / sb );	}	OrgRect->right = (OrgRect->left = dx + xo) + 1;	OrgRect->bottom = (OrgRect->top = dy + yo) + 1;		if (OrgRect->right > FilterRect->right) {		OrgRect->left = (OrgRect->right = FilterRect->right) - 1;	} else	if (OrgRect->left < FilterRect->left) {		OrgRect->right = (OrgRect->left = FilterRect->left) + 1;	}		if (OrgRect->top < FilterRect->top) {		OrgRect->bottom = (OrgRect->top = FilterRect->top) + 1;	} else	if (OrgRect->bottom > FilterRect->bottom) {		OrgRect->top = (OrgRect->bottom = FilterRect->bottom) - 1;	}	}#else	// __SINGLEPOINT__void GetOrignalPoint( Rect *FilterRect, Point *ImgPoint, Point *OrgPoint ){	double	du, dv;	long	dx, dy;	double	R;	double	cb, sb;	double	b;		long	width, height;		long	uo, vo;	long	xo, yo;			uo = xo = (FilterRect->right + FilterRect->left)/2;	vo = yo = (FilterRect->bottom + FilterRect->top)/2;		width = (FilterRect->right - FilterRect->left)/2;	height = (FilterRect->bottom - FilterRect->top)/2;		if (width < height) {		R = (double)width;	} else {		R = (double)height;	}	du = ((double)(ImgPoint->h - uo) * PIE)/(R * (double)2.0);	dv = ((double)(ImgPoint->v - vo) * PIE)/(R * (double)2.0);		cb = cos( dv ) * cos( du );	sb = sqrt(1.0 - (cb * cb) );		b = R * acos( cb ) * (double)2.0 / PIE;		if ( (sb >= (double)0.0) && (sb <= (double)(1.0 / 100.0)) ) {		dx = (long)(R * cos( dv ) * sin( du ));		dy = (long)(R * sin( dv ));	} else {		dx = (long)(b * cos( dv ) * sin( du ) / sb );		dy = (long)(b * sin( dv ) / sb );	}	OrgPoint->h = dx + xo;	OrgPoint->v = dy + yo;		if (OrgPoint->h > FilterRect->right) {		OrgPoint->h = FilterRect->right;	} else	if (OrgPoint->h < FilterRect->left) {		OrgPoint->h = FilterRect->left;	}		if (OrgPoint->v < FilterRect->top) {		OrgPoint->v = FilterRect->top;	} else	if (OrgPoint->v > FilterRect->bottom) {		OrgPoint->v = FilterRect->bottom;	}}void GetOrignalRect( Rect *FilterRect, Rect *ImgRect, Rect *OrgRect )// IN: Rect *ImgRect, OUT: Rect *OrgRect{	Point	ImgPoint, OrgPoint;		ImgPoint.v = ImgRect->top;	ImgPoint.h = ImgRect->left;		GetOrignalPoint( FilterRect, &ImgPoint, &OrgPoint );		OrgRect->right = (OrgRect->left = OrgPoint.h) + POINTS;		if (OrgRect->right > FilterRect->right) {		OrgRect->right = FilterRect->right;	}	if (OrgRect->left < FilterRect->left) {		OrgRect->left = FilterRect->left;	}		OrgRect->bottom = (OrgRect->top = OrgPoint.v - POINTS) + (POINTS * 2);		if (OrgRect->bottom > FilterRect->bottom) {		OrgRect->bottom = FilterRect->bottom;	}	if (OrgRect->top < FilterRect->top) {		OrgRect->top = FilterRect->top;	}}int GetDataPos( Rect *DataRect, Point *DataPoint, long *index )// -1: error, 0: noErr{	long width;		width = DataRect->right - DataRect->left;		if ( (width <= 0) || ((DataRect->bottom - DataRect->top) <= 0) ) {		return -1;	}		if ( (DataPoint->h < DataRect->left) || (DataPoint->h > DataRect->right) ||		(DataPoint->v < DataRect->top) || (DataPoint->v > DataRect->bottom) ) {		// out of the rect		return -1;	} else {		// within the rect		*index = ( (DataPoint->v - DataRect->top) * width 			+ (DataPoint->h - DataRect->left) );	}	return 0;}#endif	// __SINGLEPOINT__void DoPrepare (GPtr globals){#ifdef	__DEBUG__	Handle StrH;		SysBeep( 2 );	StrH = (Handle)GetString( 1002 );	HLock( (Handle)StrH );	(void)CheckDlog( ChkDlog_ID, (StringPtr)*StrH );	HUnlock( (Handle)StrH );#endif	// __DEBUG__	}void DoStart (GPtr globals){	int	i;	#ifdef	__DEBUG__	Handle StrH;	SysBeep( 2 );	StrH = (Handle)GetString( 1003 );	HLock( (Handle)StrH );	(void)CheckDlog( ChkDlog_ID, (StringPtr)*StrH );	HUnlock( (Handle)StrH );#endif	// __DEBUG__	GetTopRect( &(globals->filter_rect), &(globals->cur_out_rect) );		GetOrignalRect( 		&(globals->filter_rect), 		&(globals->cur_out_rect),		&(globals->cur_in_rect)	);	gStuff->inRect = globals->cur_in_rect;	gStuff->outRect = globals->cur_out_rect;		gStuff->inLoPlane = 0;	gStuff->inHiPlane = globals->planes -1;	gStuff->outLoPlane = 0;	gStuff->outHiPlane = globals->planes -1;	{		char buf[256];		sprintf( &(buf[1]), 			"DoStart top = %d, bottom = %d, left = %d, right = %d", 			 gStuff->inRect.top, gStuff->inRect.bottom, 			 gStuff->inRect.left, gStuff->inRect.right );		buf[0] = strlen( &(buf[1]) );		CheckDlog( ChkDlog_ID, (StringPtr)buf );	}	}void DoContinue (GPtr globals){	register int	i;	register char	*out, *in;#ifdef	__MULTIPOINT__	register int	j;#endif	// __MULTIPOINT__#if 0	Handle StrH;	SysBeep( 2 );	StrH = (Handle)GetString( 1004 );	HLock( (Handle)StrH );	(void)CheckDlog( ChkDlog_ID, (StringPtr)*StrH );	HUnlock( (Handle)StrH );#endif	if ( TestAbort() ) {		gResult = 1;		return;			} else {	#ifdef	__SINGLEPOINT__		out = (char *)gStuff->outData;		in = (char *)gStuff->inData;				for (i=0; i< (globals->planes); i++ ) {			*out++ = *in++;		}#else	// __SINGLEPOINT__// __MULTIPOINT__		for (j=0; j<POINTS; j++) {			Point	outPoint, inPoint;			long	index;						outPoint.h = gStuff->outRect.left + j;						if (outPoint.h >= gStuff->outRect.right) break;						outPoint.v = gStuff->outRect.top;						GetOrignalPoint( &(globals->filter_rect), &outPoint, &inPoint);						if ( GetDataPos( &(gStuff->inRect), &inPoint, &index ) != 0 ) {				SysBeep( 2 );			{				char buf[256];				sprintf( &(buf[1]), 					"GetDataPos top = %d, bottom = %d, left = %d, right = %d, x = %d, y = %d",					 gStuff->inRect.top, gStuff->inRect.bottom, 					 gStuff->inRect.left, gStuff->inRect.right,					 inPoint.h, inPoint.v );				buf[0] = strlen( &(buf[1]) );				CheckDlog( ChkDlog_ID, (StringPtr)buf );			}				gResult = 1;				return;			}					out = (char *)gStuff->outData + j * globals->planes;			in = (char *)gStuff->inData + index * globals->planes;					for (i=0; i< globals->planes; i++ ) {				*out++ = *in++;			}		}#endif	// __SINGLEPOINT__		if ( GetNextRect( &(globals->filter_rect), &(gStuff->outRect), &(globals->cur_out_rect) )			 == 0 ) {			SetRect( &(gStuff->inRect), 0, 0, 0, 0 );			SetRect( &(gStuff->outRect), 0, 0, 0, 0 );		} else {			if ( (globals->cur_out_rect.top & 0x0000000f) == 0) {				UpdateProgress( globals->cur_out_rect.top, 					(globals->filter_rect.bottom - globals->filter_rect.top) );			}#if 0			{				char buf[256];				sprintf( &(buf[1]), 					"top = %d, left = %d\n", globals->cur_out_rect.top, 					globals->cur_out_rect.left );				buf[0] = strlen( &(buf[1]) );				CheckDlog( ChkDlog_ID, (StringPtr)buf );			}#endif			gStuff->outRect = globals->cur_out_rect;			GetOrignalRect(  &(globals->filter_rect), 				&(globals->cur_out_rect), 				&(gStuff->inRect) );		}	}}void DoFinish (GPtr globals){#ifdef	__DEBUG__	Handle StrH;		SysBeep( 2 );	StrH = (Handle)GetString( 1005 );	HLock( (Handle)StrH );	(void)CheckDlog( ChkDlog_ID, (StringPtr)*StrH );	HUnlock( (Handle)StrH );#endif	// __DEBUG__}